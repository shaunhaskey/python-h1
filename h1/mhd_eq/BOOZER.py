#! /usr/bin/env python

"""
Class for dealing with Boozer files as generated by
xbooz_xform. See  http://vmecwiki.pppl.wikispaces.net/BOOZ_XFORM

ATTENTION: According Eq.(6) in 
R.Sanchez et al: "Ballooning stability optimization of 
low-aspect-ratio stellarators", Plasma Phys. Control. Fusion 
42 (2000) 641-653
the kernel of the Fourier series is: (m*theta_B - n*M*phi_B)!!!


ATTENTION: 
Usage:
import BOOZER
boo=BOOZER.BOOZER(bname,...)

The following does not work:
from BOOZER import BOOZER
boo=BOOZER(bname,...)



~/H1/NEO-MC/CONFIGURATIONS

zum Testen:
~/H1/VMEC/BERNHARD/FreeBoundary/BS/SCAN_FreeBound_VAC-2012-03-12/VMEC_fb_kh0.500/



ipython --pylab

%autocall 1

import BOOZER
import VMEC

vname='wout_VMEC_fb_kh0.500.nc'
bname='boozmn_VMEC_fb_kh0.500.nc'

boo=BOOZER.BOOZER(bname, 
                  compute_spline_type=BOOZER.__all_splines__, 
                  load_spline=True, 
                  save_spline=False,
                  use_spline_type=BOOZER.SPLINE.CONV_SPLINE, 
                  load_grid=False, 
                  save_grid=False)

boo=BOOZER.BOOZER(bname, 
                  compute_spline_type=BOOZER.__all_splines__, 
                  load_spline=False, 
                  save_spline=True,
                  use_spline_type=BOOZER.SPLINE.CONV_SPLINE, 
                  load_grid=False, 
                  save_grid=False)

boo=BOOZER.BOOZER(bname, compute_spline_type=BOOZER.__all_splines__, load_spline=True, save_spline=False, use_spline_type=BOOZER.SPLINE.CONV_SPLINE, compute_grid=True, load_grid=False, save_grid=True)

boo=BOOZER.BOOZER(bname, compute_spline_type=BOOZER.__all_splines__, load_spline=True, save_spline=False, use_spline_type=BOOZER.SPLINE.CONV_SPLINE, load_grid=True, compute_grid=False, save_grid=False)

wout=VMEC.VMEC(vname)

boo.plotFluxTube(s_ind=-1, no_theta=50, no_phi=360)
wout.plotFluxTube(s_ind=-1, no_theta=50, no_phi=360, figno=1)

"""


__doc__ = \
"""
A class for Boozer equilibria with some useful methods.

Some comments:

Until 19.Jan2013:

Unfortunately there is no global convention about the kernel for the 
Fourier series used for Boozer coordinates, also the factor appearing for 
phi coordinate differs in the output of different codes like 
BOOZ_XFORM (stellopt package) and MC3D. Even worse, the corresponding 
information on the VMEC wiki page is not correct!

For usage of output from BOOZ_XFORM one has to use the following formulas
for computing cylindrical (R,phi,Z) coordinates:
arg = m*theta_B - n*nfp*phi_B
R = sum_m,n R_mn * cos(arg)
phi = phi_B + 1.0 * sum_m,n Z_mn * sin(arg)
Z = sum_m,n Z_mn * sin(arg)

For usage of output from MC3D one has to use the following formulas
for computing cylindrical (R,phi,Z) coordinates:
arg = m*theta_B + n*nfp*phi_B
R = sum_m,n R_mn * cos(arg)
phi = phi_B + 2*pi/nfp* sum_m,n Z_mn * sin(arg)
Z = sum_m,n Z_mn * sin(arg)

both with m = 0...m_max and n = -n_max...0...n_max (steps for m,n are 1).

In order to deal with obove describes inconveniency the following is 
introduced in the class BOOZER:

# some factors to match different input files:
# factor A entering the evaluation of phi=phi_B+A*sum(...)
# with A=self.phi_b_fact
self.phi_b_fact = (2*PI)/self.nfp_b
# depending on the input the kernel for the Fourier series 
# is defined differently: m*theta_B + sign*N*phi_B
# with sign=self.kernelSign and N=n*nfp

__inDataType__ = {"None":None, "BOOZ_XFORM":1, "MC3D":2}

settings/values for BOOZ_XFORM:
self.phi_b_fact = 1.0
self.kernelSign = -1.
self.inDataType = __inDataType__["BOOZ_XFORM"]

settings/values for MC3D:
self.phi_b_fact = (PI2)/self.nfp_b
self.kernelSign = 1.
self.inDataType = __inDataType__["MC3D"]


History:

14.Apr.2013 bhs
* refined real2Mag() in order to invert coordinates without pre-computed grid
* added stGuessRPZ()

19.Jan.2013 bhs
* imlemented loadTxtFile() in order to read output of MC3D code.
* introduced self.kernelSign and self.inDataType as well as different 
  values for self.phi_b_fact in order to deal with different output files 
  of the codes BOOZ_XFORM and MC3D. See comment above History section.
* removed: calc_rz_coefs2(), calc_rpz_coefs2()

10.Dec.2012 bhs
* add show_converge_diagnostic to __init__()

04.Dec.2012 bhs
* getFluxsurfData()  meshgrid output is now available (optional)

09.Aug.2012 bhs
* minor cleanup for plot routines

08.Aug.2012 bhs
* make use of H1ErrorClasses

21.Jun.2012 bhs
* use class GRID3D

04.Jun.2012 bhs
* clean names for calling imported packages, e.g. pl -> pylab

23.Apr.2012 bhs
* Some modification in writeNeoInput() to match inp_swi=8 in neo-code.
  line2a1 and line2a2.

09.Apr.2012
* Spline for Rmn, Zmn, Pmn and Bmn added
* plot cross section for phi_cylindrical=const
* 3d coordinate inversion

22.Mar.2012 bhs
* getCrossSectData() split off from plotCrossSect()

17 March 2012 bhs
* first version of writeNeoInput()  added

29 November 2011 bhs
* start with this script
"""

"""
Summing up Fourier series is done in:
fct_RZ(), fct_RPZ(), fct_P(), ct_phi_c(), getFluxSurfData(), getCrossSectData()

"""

__version__ = "0.5"
__versionTime__ = "19 Jan 2013"
__author__ = "Bernhard Seiwald <bernhard.seiwald@gmail.com>"


import os
import sys
import time
import numpy
from scipy import interpolate
#from scipy import optimize
from scipy.optimize import minpack
import scipy.optimize as optimize

import pylab
import warnings
from copy import deepcopy

try:
    import mpl_toolkits.mplot3d.axes3d as p3
except:
    from mpl_toolkits.mplot3d import Axes3D

try:
    from scipy.io import netcdf
    net_cdf_module = 'netcdf'
except ImportError:
    try:
        import netCDF4 as netcdf
        netcdf_module = 'netCDF4'
    except: raise ImportError('Unable to load netcdf module/library')


from H1ErrorClasses import *
import convenience
import netCDF4Tools
import SPLINE
from spline_spec import leadingfunction_mod as leadingfunction
from spline_spec import spline_spec_mod as spline_spec
import GRID3D
import miscmath

# try:
#     from mayavi import mlab
#     ISOK_MAYAVI = True
# except:
#     ISOK_MAYAVI = False
ISOK_MAYAVI = False

PI = numpy.pi
PI2 = 2.*PI

debug=0

__inDataType__ = {"None":None, "BOOZ_XFORM":1, "MC3D":2}

__all__ = ['BOOZER']


__all_splines__ = -1

class BOOZER():
    """
    A class for Boozer models

    Author: Bernhard Seiwald
    Date:   

    """

    def __init__(self, 
                 nc_filename, 
                 import_all=True, 
                 show_vars=False, 
                 maxm=None, 
                 compute_spline_type=None, 
                 load_spline=True, 
                 save_spline=False,
                 use_spline_type=SPLINE.CONV_SPLINE, 
                 compute_grid=False,
                 load_grid=True, 
                 save_grid=False, 
                 gridfunction=None,
                 gnr=None, gnp=None, gnz=None,
                 show_converge_diagnostic=False):
        """

        INPUT:
          nc_filename, 
          import_all=True, 
          show_vars=False, 
          maxm=None, 
          compute_spline_type=__all_splines__, 
          load_spline=True, 
          save_spline=False,
          use_spline_type=SPLINE.CONV_SPLINE, 
          compute_grid=False,
          load_grid=True, 
          save_grid=False, 
          gridfunction=None,
          gnr=None, gnp=None, gnz=None,
          show_converge_diagnostic=False
        """
        print "loading BOOZER file " + nc_filename + "..."

        #self.import_all = import_all
        self.import_all = True
        self.inDataType = __inDataType__["None"]
        self.nc_filename = nc_filename
        try:
            self.ds = netcdf.netcdf_file(self.nc_filename, 'r')
            if import_all:
                self.importAll()
                # some factors to match different input files:
                # factor A entering the evaluation of phi=phi_B+A*sum(...)
                # with A=self.phi_b_fact
                #self.phi_b_fact = (PI)/self.nfp_b
                # Shaun thanksfully figured out that phi_b_fact = 1. 
                # for BOOZ_XFORM
                self.phi_b_fact = 1.
                # depending on the input the kernel for the Fourier series 
                # is defined differently: m*theta_B + sign*N*phi_B
                # with sign=self.kernelSign and N=n*nfp
                self.kernelSign = -1.
                self.inDataType = __inDataType__["BOOZ_XFORM"]
            # end   if import_all:
        except:
            if(not self.nc_filename.endswith('.nc')):
                # probably we have a text file
                # In that case, we always import the variables in order not 
                # to rebuild/copy the structure netcdf returns!
                self.loadTxtFile()
                self.es = [1]
                self.es_b = [1]
                # some factors to match different input files:
                # factor A entering the evaluation of phi=phi_B+A*sum(...)
                # with A=self.phi_b_fact
                self.phi_b_fact = (PI2)/self.nfp_b
                # depending on the input the kernel for the Fourier series 
                # is defined differently: m*theta_B + sign*N*phi_B
                # with sign=self.kernelSign and N=n*nfp
                self.kernelSign = 1.
                self.inDataType = __inDataType__["MC3D"]
            else:
                raise Exception("No valid Boozer file!")
            # end   if(not self.nc_filename.endswith('.nc')):
        # end   try:

        self.DMU0 = 4.0*numpy.pi*1.0e-7        # 1.256637d-06

        self.ncpath,ncfname = os.path.split(self.nc_filename)
        self.config_name, scfilename_ext = os.path.splitext(ncfname)

        if(self.inDataType == __inDataType__["BOOZ_XFORM"]):
            self.es = numpy.array(self.ds.variables['phi_b'][:]/max(self.ds.variables['phi_b']))
            #self.es_b = self.es[self.ds.variables['jlist'].data-1]
            self.es_b = (-self.phi_b[1:]/self.phip_b[1:]/(2.*numpy.pi))[self.jlist-1]
        # end   self.inDataType == __inDataType__["BOOZ_XFORM"]

        self.compute_spline_type = 0
        if(compute_spline_type == None):
            compute_spline_type = 0

        if(compute_spline_type == __all_splines__):
            self.compute_spline_type = self.allSplMeths()
        else:
            self.compute_spline_type = compute_spline_type

        self.splkind = use_spline_type

        # compute coefficients for splines
        self.spline_coefs_done = False
        spline_name = "".join([self.config_name, '.splcoef'])
        if(load_spline):
            try:
                print "try loading spline coefficients..."
                print "".join([spline_name, ".Rmnc_b"])
                self.rSpline = SPLINE.SPLINE(nc_name="".join([spline_name, 
                                                              ".Rmnc_b"]))
                self.pSpline = SPLINE.SPLINE(nc_name="".join([spline_name, 
                                                              ".Pmns_b"]))
                self.zSpline = SPLINE.SPLINE(nc_name="".join([spline_name, 
                                                              ".Zmns_b"]))
                self.bSpline = SPLINE.SPLINE(nc_name="".join([spline_name, 
                                                              ".Bmnc_b"]))
                print "...spline coefficients loaded"
                self.spline_coefs_done = True
            except:
                print "can't load spline coefficients"

        if((compute_spline_type != 0) and not self.spline_coefs_done):
            self.calc_spline_coefs()
            if(save_spline):
                self.rSpline.save("".join([spline_name, ".Rmnc_b"]))
                self.pSpline.save("".join([spline_name, ".Pmns_b"]))
                self.zSpline.save("".join([spline_name, ".Zmns_b"]))
                self.bSpline.save("".join([spline_name, ".Bmnc_b"]))

        # compute 3D grid if asked for
        if(gridfunction == None):
            gridfunction=self.fct_RPZ

        self.maxm = maxm
        grid_name = "".join([self.config_name, '.grid3D.nc'])
        #try:
        self.grid3D = GRID3D.GRID3D(nc_filename=grid_name, 
                                        compute_grid=compute_grid,
                                        load_grid=load_grid, 
                                        save_grid=save_grid,
                                        gridfunction=gridfunction, 
                                        gnr=gnr, gnp=gnp, gnz=gnz)
        #except:
        #    print "grid3D can't be provided..."
        print "3d grid is {0:s}available".format("" if self.grid3D.isAvail else "not ")

        if(show_vars): show_variables(self.ds.variables)


        """
        # check to see if boozer series diverges.
        self.rmsmagm = []
        for m in numpy.unique(self.ixm_b):
            mvals = numpy.where(self.ixm_b == m)[0]
            self.rmsmagm.append(sum(abs(self.rmnc_b[-1][mvals])))
        slope=numpy.diff(self.rmsmagm)

        # do n also, but m is the culprit I think
        self.rmsmagn = []
        for n in numpy.unique(self.ixn_b):
            nvals = numpy.where(self.ixn_b == n)[0]
            self.rmsmagn.append(sum(abs(self.rmnc_b[-1][nvals])))

        # tricky setting of default maximum m value
        # we are waiting to check convergence before deciding    
        #self.maxm = self.ds.variables['mboz_b'].getValue()
        self.maxm = maxm
        if ((max(slope*self.rmsmagm[1:]) > 1e-8) 
            or (self.rmsmagn[-1]>min(self.rmsmagn)*100)):
            if(show_converge_diagnostic):
                pylab.figure()
                pylab.semilogy(self.rmsmagm,label= 'vs m')
                pylab.semilogy(numpy.unique(self.ixn_b),self.rmsmagn,label= 'vs n')
                pylab.title('rmnc_b magnitude')
                pylab.legend()
                pylab.show()
            # end   if(show_converge_diagnostic):
            # only interfere is divergence is suspected
            # set default max m to 5 higher than the minimum term index
            maxm_cvg = numpy.argsort(self.rmsmagm)[0]+5
            warnings.warn('Boozer rmnc series is apparently diverging')
            if self.maxm == None:
                self.maxm = maxm_cvg
                print('truncating sums at %d' % (self.maxm))
            else:
                if self.maxm>maxm_cvg:
                    warnings.warn('User supplied maxm=%d used is greater '
                                  'than recommened value of %d' 
                                  % (self.maxm, maxm_cvg))

        if (max(slope*self.rmsmagm[1:]) > 1e-4) and (self.maxm>maxm_cvg):
            raise ValueError('Boozer rmnc series is apparently diverging seriously')
        """

        print "...BOOZER file " + nc_filename + " loaded"
        #print "self.kernelSign=", self.kernelSign
        #print "self.inDataType=", self.inDataType

        # check to make sure surfaces are monotonic increasing
        if(self.inDataType == __inDataType__["BOOZ_XFORM"]):
            if min(self.es[1:] - self.es[:-1]) <= 0:
                raise Exception("Surfaces are not monotonic increasing")
            # end   if min(self.es[1:] - self.es[:-1]) <= 0:
        # end   self.inDataType = __inDataType__["BOOZ_XFORM"]

        return


    def loadTxtFile(self):
        """
        Here we try to read a textfile with Boozer data.

        The current (14.Jan.2013) implementation is for MC3D output file 
        boundary_matlab_mc3d.dat

        Returns within the BOOZER class:
          rmnc_b, zmns_b, pmns_b, bmnc_b, ixm_b, ixn_b, 
          ns_b, comput_surfs, nfp_b, mboz_b, nboz_b, mnboz_b

        ATTENTION: As there is no value for nfp_b stored in the MC3D file
                   we assume the file is for H1. Therefore, nfp_b is set 
                   to nfp_b=3!!!
                   In these files only LCMS is stored, so ns_b=1.

        INPUT:
          None
        
        USES: 
          self.nc_filename

        RETURN:
          None
        """

        print "".join(["ATTENTION: As there is no value for nfp_b ",
                       "stored in the MC3D file\n",
                       "we assume the file is for H1.\n",
                       "Therefore, nfp_b is set to nfp_b=3!!!\n",
                       "In these files only LCMS is stored, so ns_b=1."])

        fd = open(self.nc_filename, 'r')
        lines = fd.readlines()
        fd.close()

        self.ns_b = 1
        self.comput_surfs = 1
        self.nfp_b = 3
        ixm_b = []
        ixn_b = []
        rmnc_b = []
        zmns_b = []
        pmns_b = []
        bmnc_b = []
        for line in lines:
            ll = line.strip()
            if(len(ll) > 0):
                try:
                    l = ll.split()
                    dummy = float(l[0])
                    if(len(l) == 1):
                        no_modes = int(l[0])
                        counter = 0
                    else:
                        ixm_b.append(int(l[0]))
                        ixn_b.append(int(l[1]))
                        rmnc_b.append(float(l[2]))
                        zmns_b.append(float(l[3]))
                        pmns_b.append(float(l[4]))
                        bmnc_b.append(float(l[5]))
                        counter += 1
                    # end   if(len(l) == 1):
                except:
                    pass
                # end   try:
            # end   if(len(ll) > 0):
        # end   for line in lines:
        if(counter != no_modes):
            raise Exception, "problem while parsing file {0:s}: read {1:d}, should be {2:d}".format(self.nc_filename, counter, no_modes)
        # end   if(counter != no_modes):

        self.ixm_b = numpy.array(ixm_b)
        self.ixn_b = numpy.array(ixn_b)
        # depending on the input the kernel for the Fourier series 
        # is defined differently: m*theta_B + sign*N*phi_B
        # with sign=self.kernelSign and N=n*nfp
        if((self.ixn_b[1] - self.ixn_b[0]) == 1):
            self.ixn_b *= self.nfp_b
        # end   if((self.ixb_b[1] - self.ixb_b[0]) == 1):
        self.mboz_b = self.ixm_b.max()+1
        self.nboz_b = self.ixn_b.max() / self.nfp_b
        self.mnboz_b = self.ixm_b.shape[0]
        self.rmnc_b = numpy.empty([1,self.mnboz_b])
        self.zmns_b = numpy.empty([1,self.mnboz_b])
        self.pmns_b = numpy.empty([1,self.mnboz_b])
        self.bmnc_b = numpy.empty([1,self.mnboz_b])
        self.rmnc_b[0,:] = numpy.array(rmnc_b)
        self.zmns_b[0,:] = numpy.array(zmns_b)
        self.pmns_b[0,:] = numpy.array(pmns_b)
        self.bmnc_b[0,:] = numpy.array(bmnc_b)
        return


    def importAll(self):
        """

        Import all variables.
        Set self.import_all = True

        """

        # dimensions
        dimensions = self.ds.dimensions
        for var in dimensions:
            destvar = convenience.clearFilename(var)
            destvar = destvar.replace('-', '_')
            exestr = "self."+destvar+"=self.ds.dimensions['"+var+"']"
            exec(exestr)

        # variables
        variables = self.ds.variables
        for var in variables:
            if(len(self.ds.variables[var].shape) == 0):
                exestr = "self."+var+"=self.ds.variables['"+var+"'].getValue()"
                exec(exestr)
            else:
                exestr = "self."+var+"=self.ds.variables['"+var+"'][:]"
                exec(exestr)

        try:
            self.jlist = self.jlist-1
        except:
            pass

        self.import_all = True
        return


    def show_variables(variables, max_width=80, indent='  '):
        """
        """

        line = indent
        for k in variables.keys(): 
            if len(variables[k].shape) == 0:
                op = str('%s=%s' % (k,variables[k].getValue()))
            else:
                op = str('%s arr%s' % (k,variables[k].shape))
            if len(line+op) > max_width:
                print line
                line = indent
            else: line += op + ', '
        if line != indent: print line
    
        return(0)





    ##### some stuff for interpolation start #####

    def allSplMeths(self):
        """
        Determine all methods, which are provided by SPLINE. 


        INPUT:
          None

        RETURN:
          allmeths ... integer number representing all methods
        """
        spl = SPLINE.SPLINE({'x':numpy.arange(5), 'y':numpy.arange(5)})
        allmeths = sum(spl.SPLINE_METHODS_l)
        del(spl)

        return(allmeths)


    def calc_spline_coefs(self):
        """
        Calculate spline coefficients.

        Have a good look at the documentation of the calss SPLINE!

        * for computation of coefficients the flag compute_spline_type
          is taken into account: 
         if SQRT_SPLINE:
            divide odd m terms by sqrt(s), keep even m terms as they are
            use 3rd order qubic spline

         if CONV_SPLINE:
            use just 3rd order qubic spline

         if SPECIAL_SPLINE:
            use special spline equiped with leading function (takes into
            account sqare root characteristics of Rmnc, Zmns).
            make sure that spline_spec is imported.

        * for interpolation/evaluation: 
          use e.g. rSpline(s, deriv=False, kindspec=None)


        INPUT:
          None

        RETURN:
          None
        """

        if(not self.import_all):
            self.importAll()   # we need to import the quantities

        self.rSpline = SPLINE.SPLINE({'x':self.es_b, 
                                      'y':self.rmnc_b, 
                                      'kindspec':self.compute_spline_type, 
                                      'ixm':self.ixm_b})
        self.pSpline = SPLINE.SPLINE({'x':self.es_b, 
                                      'y':self.pmns_b, 
                                      'kindspec':self.compute_spline_type, 
                                      'ixm':self.ixm_b})
        self.zSpline = SPLINE.SPLINE({'x':self.es_b, 
                                      'y':self.zmns_b, 
                                      'kindspec':self.compute_spline_type, 
                                      'ixm':self.ixm_b})
        self.bSpline = SPLINE.SPLINE({'x':self.es_b, 
                                      'y':self.bmnc_b, 
                                      'kindspec':self.compute_spline_type, 
                                      'ixm':self.ixm_b})
        self.spline_coefs_done = True
        print "...done"
        return




    def fct_phi_c(self, phi_b, args):
        """
        (f, f1) = fct_phi_c(self, phi_b, args)

        Compute phi_c = phi_c(phi_b) and first derivative
        RETURN   phi_c-phi0_c

        ATTENTION: needed args, array like
                     args[0]=phi0_c
                     args[1]=theta_b
                     args[2]=pureInd
        
        This function is needed for e.g. inversion in Boozer2Real()
        """
        a = self.phi_b_fact
        #phi_b = numpy.mod(phi_b,PI2)
        arg = self.ixm_b*args[1] + self.kernelSign*self.ixn_b*phi_b
        f  = phi_b + a*numpy.sum(self.pmns*numpy.sin(arg)) - args[0]
        #f1 = 1. + a*numpy.sum(self.ixn_b*self.pmns*numpy.cos(arg))
        return(f)


    def fct_P(self, s, theta_b, phi_b, calc_derivs=False, pureInd=False):

        """
        (phi, phis, phit, phip) = 
                  fct_P(self, s, theta_b, phi_b, calc_derivs=True)

        (phi) = 
                  fct_P(self, s, theta_b, phi_b, calc_derivs=False)

        Compute 
        phi(s,theta_b,phi_b) = phi_b - a*SUM(pmns_b*sin(ixm*theta_b + ixn*phi_b))
        with a=1 or a=(2.*pi)/self.nfp_b  depending on definition in BOOZ_XFORM
        and the derivatives with respect to s, theta_b and phi_b.
        rmnc_b, zmns_b, pmns_b ... Boozer 'spectra'

        Returns phi and derivatives.

        INPUT:
          s ..... flux surface label
          theta_b, 
          phi_b .. angle like Boozer variables
          calc_derivs . compute derivatives (logical)
          pureInd  if True than s=es[s_ind]  s i interpreted as index

        OUTPUT:
          phi
          phis, phit, phip ... derivatives of phi with respect to 
                               s, theta_b, phi_b
                            
        """
        #pureInd=True
        #calc_derivs=False
        maxm = None

        if(s != 0.0):
            les = s
        else:
            les = 1.0e-30

        # DON'T USE MODULO FUNCTION! RESULTS ARE WRONG FOR PHI!
        #phi_b = numpy.mod(phi_b,PI2)

        if(calc_derivs):
            if(pureInd):
                #(pmn, pmns) = self.pmns_b[s]
                raise Exception("no valid combination: calc_derivs=True and pureInd=True")
            else:
                (pmn, pmns) = self.calc_p_coefs(les, calc_derivs=calc_derivs)
            # end   if(pureInd)
        else:
            if(pureInd):
                pmn = self.pmns_b[s]
            else:
                pmn = self.calc_p_coefs(les, calc_derivs=calc_derivs)
            # end   if(pureInd)
        # end   if(calc_derivs):

        if(maxm == None): maxm = self.maxm

        if(maxm != None):
            elts_used = numpy.where(self.ixm_b<maxm)[0]
        else:
            elts_used = numpy.arange(len(self.rmnc_b[0]))

        ixm = self.ixm_b #[elts_used]
        ixn = self.ixn_b #[elts_used]

        pmn = pmn #[elts_used]

        if(calc_derivs):
            pmns = pmns #[elts_used]

        argv = ixm*theta_b + self.kernelSign*ixn*phi_b
        sinv = numpy.sin(argv)
        cosv = numpy.cos(argv)
  
        a = self.phi_b_fact
        phi = phi_b + a*sum(pmn * sinv)

        if(calc_derivs):
            phis = a*sum(pmns * sinv)
            phit = a*sum(pmn * cosv * ixm)
            phip = a*self.kernelSign*sum(pmn * cosv * ixn)

        if(calc_derivs):
            return(phi, phis, phit, phip)
        else:
            return(phi)



    def fct_RZ(self, s, theta_b, phi_b, calc_derivs=False):

        """
        (R, Z, Rs, Rt, Rp, Zs, Zt, Zp) = 
             fct_RZ(self, s, theta_b, phi_b, calc_derivs=True)

        (R, Z) = 
             fct_RZ(self, s, theta_b, phi_b, calc_derivs=False)

        Compute 
        R(s,theta_b,phi_b) = SUM(rmnc_b*cos(ixm*theta_b + ixn*phi_b))
        and 
        Z(s,theta_b,phi_b) = SUM(zmns_b*sin(ixm*theta_b + ixn*phi_b))
        and the derivatives with respect to s and theta_b.
        rmnc_b, zmns_b ... Boozer 'spectrum'

        Returns R, Z and derivatives.

        INPUT:
          s ...... flux surface label
          theta_b, 
          phi_b .. angle like Boozer variables
          calc_derivs . compute derivatives (logical)

        OUTPUT:
          R, Z
          Rs, Rt, Rp ... derivatives of R with respect to s, theta_b, phi_b
          Zs, Zt, Zp ... derivatives of Z with respect to s, theta_b, phi_b

        """

        maxm = None

        if(s != 0.0):
            les = s
        else:
            les = 1.0e-30

        #phi_b = numpy.mod(phi_b,PI2)
        if(calc_derivs):
            (Rmn, Zmn, Rmns, Zmns) = self.calc_rz_coefs(les, calc_derivs=calc_derivs)
        else:
            (Rmn, Zmn) = self.calc_rz_coefs(les, calc_derivs=calc_derivs)

        if(maxm == None): maxm = self.maxm

        #if(maxm != None):
        #    elts_used = numpy.where(self.ixm_b<maxm)[0]
        #else:
        #    elts_used = numpy.arange(len(self.rmnc_b[0]))

        ixm = self.ixm_b #[elts_used]
        ixn = self.ixn_b #[elts_used]
        Rmn = Rmn #[elts_used]
        Zmn = Zmn #[elts_used]

        if(calc_derivs):
            Rmns = Rmns #[elts_used]
            Zmns = Zmns #[elts_used]

        argv = ixm*theta_b + self.kernelSign*ixn*phi_b
        cosv = numpy.cos(argv)
        sinv = numpy.sin(argv)
  
        R = sum(Rmn * cosv)
        Z = sum(Zmn * sinv)

        if(calc_derivs):
            Rs =  sum(Rmns * cosv)
            Rt = -sum(Rmn * sinv * ixm)
            Rp = -self.kernelSign*sum(Rmn * sinv * ixn)
            Zs =  sum(Zmns * sinv)
            Zt =  sum(Zmn * cosv * ixm)
            Zp =  self.kernelSign*sum(Zmn * cosv * ixn)

        if(calc_derivs):
            return(R, Z, Rs, Rt, Rp, Zs, Zt, Zp)
        else:
            return(R, Z)



    def fct_RPZ(self, s, theta_b, phi_b, calc_derivs=False):

        """
        (R, phi, Z, Rs, Rt, Rp, phis, phit, phip, Zs, Zt, Zp) = 
                  fct_RPZ(self, s, theta_b, phi_b, calc_derivs=True)

        (R, phi, Z) = 
                  fct_RPZ(self, s, theta_b, phi_b, calc_derivs=False)

        Compute 
        R(s,theta_b,phi_b) = SUM(rmnc_b*cos(ixm*theta_b + ixn*phi_b))
        Z(s,theta_b,phi_b) = SUM(zmns_b*sin(ixm*theta_b + ixn*phi_b))
        and 
        phi(s,theta_b,phi_b) = phi_b - a*SUM(pmns_b*sin(ixm*theta_b + ixn*phi_b))
        with a=1 or a=(2.*pi)/self.nfp_b  depending on definition in BOOZ_XFORM
        and the derivatives with respect to s, theta_b and phi_b.
        rmnc_b, zmns_b, pmns_b ... Boozer 'spectra'

        Returns R, phi, Z and derivatives.

        INPUT:
          s ..... flux surface label
          theta_b, 
          phi_b .. angle like Boozer variables
          calc_derivs . compute derivatives (logical)

        OUTPUT:
          R, phi, Z
          Rs, Rt, Rp ... derivatives of R with respect to s, theta_b, phi_b
          phis, phit, phip ... derivatives of phi with respect to 
                               s, theta_b, phi_b
          Zs, Zt, Zp ... derivatives of Z with respect to s, theta_b, phi_b

        """

        maxm = None

        if(s != 0.0):
            les = s
        else:
            les = 1.0e-30

        #phi_b = numpy.mod(phi_b,PI2)

        if(calc_derivs):
            (Rmn, pmn, Zmn, Rmns, pmns, Zmns) = self.calc_rpz_coefs(les, calc_derivs=calc_derivs)
        else:
            (Rmn, pmn, Zmn) = self.calc_rpz_coefs(les, calc_derivs=calc_derivs)

        if(maxm == None): maxm = self.maxm

        if(maxm != None):
            elts_used = numpy.where(self.ixm_b<maxm)[0]
        else:
            elts_used = numpy.arange(len(self.rmnc_b[0]))

        ixm = self.ixm_b #[elts_used]
        ixn = self.ixn_b #[elts_used]

        Rmn = Rmn #[elts_used]
        pmn = pmn #[elts_used]
        Zmn = Zmn #[elts_used]

        if(calc_derivs):
            Rmns = Rmns #[elts_used]
            pmns = pmns #[elts_used]
            Zmns = Zmns #[elts_used]

        argv = ixm*theta_b + self.kernelSign*ixn*phi_b
        cosv = numpy.cos(argv)
        sinv = numpy.sin(argv)
  
        R = sum(Rmn * cosv)
        a = self.phi_b_fact
        phi = phi_b + a*sum(pmn * sinv)
        Z = sum(Zmn * sinv)

        if(calc_derivs):
            Rs =  sum(Rmns * cosv)
            Rt = -sum(Rmn * sinv * ixm)
            Rp = -self.kernelSign*sum(Rmn * sinv * ixn)
            phis =  a*sum(pmns * sinv)
            phit =  a*sum(pmn * cosv * ixm)
            phip =  a*self.kernelSign*sum(pmn * cosv * ixn)
            Zs =  sum(Zmns * sinv)
            Zt =  sum(Zmn * cosv * ixm)
            Zp =  self.kernelSign*sum(Zmn * cosv * ixn)

        if(calc_derivs):
            return(R, phi, Z, Rs, Rt, Rp, phis, phit, phip, Zs, Zt, Zp)
        else:
            return(R, phi, Z)


    def calc_p_coefs(self, s, calc_derivs=True):
        """
        (pmns, pmnss) = calc_p_coefs(self, s, calc_derivs=True)

        Compute coefficients pmns_b(s).
        The derivatives with respect to s are computed 
        if set: calc_derivs=True. 
        All modes are taken into account.
        Number of modes for pmns_b(s) are assumed to 
        be the same and not 'cross checked'!

        RETURN:
          pmns, pmnss ... if set calc_derivs=True
          pmns .......... if set calc_derivs=False
       """

        if (not self.spline_coefs_done):
            print 'calculating spline coefs'
            self.calc_spline_coefs()

        PP = self.pSpline.eval(s, deriv=calc_derivs, kindspec=self.splkind)

        if calc_derivs:
            return(PP[0,0,:], PP[0,1,:])
        else:
            return(PP[0,:])


    def calc_rz_coefs(self, s, calc_derivs=True):
        """
        (rmnc, zmns, rmncs, zmnss) = calc_rz_coefs(self, s, calc_derivs=True)

        Compute coefficients rmnc_b(s), zmns_b(s).
        The derivatives with respect to s are computed 
        if set: calc_derivs=True. 
        All modes are taken into account.
        Number of modes for rmnc_b(s), zmns_b(s) are assumed to 
        be the same and not 'cross checked'!

        RETURN:
          rmnc, zmns, rmncs, zmnss ... if set calc_derivs=True
          rmnc, zmns ................. if set calc_derivs=False
        """

        if (not self.spline_coefs_done):
            print 'calculating spline coefs'
            self.calc_spline_coefs()

        RR = self.rSpline.eval(s, deriv=calc_derivs, kindspec=self.splkind)
        ZZ = self.zSpline.eval(s, deriv=calc_derivs, kindspec=self.splkind)

        if calc_derivs:
            return(RR[0,0,:], ZZ[0,0,:], 
                   RR[0,1,:], ZZ[0,1,:])
        else:
            return(RR[0,:], ZZ[0,:])



    def calc_rpz_coefs(self, s, calc_derivs=True):
        """
        (rmnc, pmns, zmns, rmncs, pmnss, zmnss) = calc_rpz_coefs(self, s, calc_derivs=True)

        Compute coefficients rmnc_b(s), pmns_b(s), zmns_b(s).
        The derivatives with respect to s are computed 
        if set: calc_derivs=True. 
        All modes are taken into account.
        Number of modes for rmnc_b(s), zmns_b(s), pmns_b(s) are assumed to 
        be the same and not 'cross checked'!

        RETURN:
          rmnc, pmns, zmns, rmncs, pmnss, zmnss ... if set calc_derivs=True
          rmnc, pmns, zmns ........................ if set calc_derivs=False
       """

        if (not self.spline_coefs_done):
            print 'calculating spline coefs'
            self.calc_spline_coefs()

        RR = self.rSpline.eval(s, deriv=calc_derivs, kindspec=self.splkind)
        PP = self.pSpline.eval(s, deriv=calc_derivs, kindspec=self.splkind)
        ZZ = self.zSpline.eval(s, deriv=calc_derivs, kindspec=self.splkind)

        if calc_derivs:
            return(RR[0,0,:], PP[0,0,:], ZZ[0,0,:], 
                   RR[0,1,:], PP[0,1,:], ZZ[0,1,:])
        else:
            return(RR[0,:], PP[0,:], ZZ[0,:])


    ##### some stuff for interpolation end #####


    ##### some stuff for inverting coordinates start #####


    def residualP(self, phi_b, args):
        """
        Computes fct_P(phi_b)-Phi0

        Needed e.g. for 3d coordinate inversion 
        cylindrical coordinates -> Boozer

        
        INPUT:
          phi_b . Boozer angle
          args .. array like:  [Phi0, s, theta_b, pureInd]

        RETURN:
          fct_P(p)-P0
        """
        return(self.fct_P(args[1],args[2],phi_b,calc_derivs=False,pureInd=args[3])-args[0])

    def residualRPZ(self, x, y0):
        """
        Computes fct_RPZ(x)-y0

        Needed e.g. for 3d coordinate inversion 
        cylindrical coordinates -> Boozer

        
        INPUT:
          x ... Boozer coordinates (s, theta_b, phi_b)
          y ... cylindrical coordinates (R, phi, Z)

        RETURN:
          fct_RPZ(x)-y0
        """
        return(numpy.array(self.fct_RPZ(x[0],x[1],x[2])[:3])-numpy.array(y0))

    def residualRPZ2(self, x, y0):
        """
        Computes fct_RPZ(x)-y0

        Needed e.g. for 3d coordinate inversion 
        cylindrical coordinates -> Boozer

        
        INPUT:
          x ... Boozer coordinates (s, theta_b, phi_b)
          y ... cylindrical coordinates (R, phi, Z)

        RETURN:
          fct_RPZ(x)-y0
        """
        return numpy.sum((numpy.array(self.fct_RPZ(x[0],x[1],x[2])[:3])-numpy.array(y0))**2)



    def real2Mag(self, phi_plane, RZ, acc=1.0e-3, interp_params=None, debug=0):
        """
        Invertes cylindrical coordinates (R,phi,Z) 
        to Boozer (s, theta_b, phi_b)

        INPUT:
          phi_plane . scalar defining phi-plane in cylindrical coordinates
                      in rad
          RZ ........ R,Z coordinates in specified phi-plane
                      dimension: RZ[n,2]
          acc ....... accuracy in units of R,Z (most likely R,Z are in meters)
          interp_params  parameters for interpolation; dictionary
                         e.g.:  default_params = {
            'st_res': [35j,100j], # grid in s,theta space to xform to cart
            'rz_res': [130j, 130j], # the uniform grid in cylindrical space.
            'extent': [1.0,1.38,-.25,.25] # in r,z space rmin,rmax,zmin,zmax
            }
            In case interp_params is not provided by the user the values 
            for 'extent' are determined automatically.

        RETURN:
          stp ... array containing s, theta_b, phi_b
                  dimension:  stp[n,3]
        """

        if(debug != 0):
            print "real2Mag(): inversion on phi={0:7.2f}deg plane".format(numpy.
rad2deg(phi_plane))
            print "interp_params ", interp_params
            print "RZ ", RZ
        # end   if(debug != 0):

        RZ = numpy.array(RZ)
        dim = RZ.shape
        if(len(dim) == 1):
            no_points = 1
            if(dim[0] != 2):
                raise InputDataError("".join(["For a single point only ",
                                              "one pair (RZ) is allowed!"]))
            # end   if(dim[0] != 2):
            RZ = RZ.reshape([no_points,dim[0]])
        elif(len(dim) == 2):
            no_points = dim[0]
        else:
            raise InputDataError("".join(["Input coordinates (R,Z) must ",
                                          "have dimension [n,2]!"]))
        # end   if(len(dim) == 1):

        """
        default_params = {        # these do error <=1e-4, for cubic interp
            'st_res': [35j,100j], # grid in s,theta space to xform to cart
            'rz_res': [130j, 130j], # the uniform grid in Cartesian space.
            'extent': [1.0,1.38,-.25,.25] # in r,z space rmin,rmax,zmin,zmax
            }

        if (debug>1): 
            print('interp_params (default)\n %s' % (default_params))
        # end   if (debug>1): 

        if(interp_params == None):
            int_pms = deepcopy(default_params)
        else:
            int_pms = deepcopy(interp_params)
        # end   if(interp_params == None):

        if (debug>1): 
            print('int_pms (input)\n %s' % (int_pms))
        # end   if (debug>1): 
        """

        # initialise array with results, stp, with nan
        stp = numpy.empty([no_points,3])
        stp.fill(numpy.nan)

        no_theta = 100
        csd = self.getCrossSectData(phi_plane, None, s_ind=-1, 
                                    no_theta=no_theta, coordsys="cyl",
                                    phi_is_cyl=True)[0]

        """
        # adjust limits for R and Z using values computed with s=1
        # in case user did not provide interp_params
        if(interp_params == None):
            lim = []
            rmin = csd[0,:].min()
            rmax = csd[0,:].max()
            zmin = csd[2,:].min()
            zmax = csd[2,:].max()
            lim.append(rmin - 0.1*numpy.abs(rmin))
            lim.append(rmax + 0.1*numpy.abs(rmax))
            lim.append(zmin - 0.1*numpy.abs(zmin))
            lim.append(zmax + 0.1*numpy.abs(zmax))
            int_pms.update({'extent':lim})
        # end   if(interp_params == None):

        if (debug>1): 
            print('int_pms (actual)\n %s' % (int_pms))
        # end   if (debug>1): 
        """

        # last closed magnetic surface
        lcms = csd[[0,2],:]
        #print 'lcms.shape ', lcms.shape

        # magnetic axis
        phi_b1 = self.invertP(0, 0,  phi_plane, pureInd=True)
        ma = numpy.empty(2)
        (ma[0],ma[1]) = self.fct_RZ(0, 0, phi_b1)

        # As the 3d inversion is ambigous, we need proper values for 
        # a guess in order to give the algorithm a chance to convert 
        # to the right value...
        phi = phi_plane
        #phi = numpy.mod(phi_plane,PI2)
        previous_answer = None
        for i in range(no_points):
            ir = RZ[i,0]
            iz = RZ[i,1]

            l = True
            # check whether point is directly on lcms
            if(not [ir,iz] in lcms):
                # check whether point is inside lcms
                if(miscmath.wn_PnPoly([ir,iz], lcms.T) == 0):
                    # As no_theta is not infinite, 
                    # winding number may give a wrong answer.
                    # Accept also points which are sufficiently close to LCMS.
                    d_max = numpy.max(numpy.abs(numpy.diff(lcms))) / 2.
                    P = numpy.array([ir,iz])
                    PP = P.repeat(no_theta).reshape([2,no_theta])
                    Pd = numpy.sqrt(((lcms-PP)**2).sum(0))
                    if(numpy.min(numpy.abs(Pd)) > d_max):
                        stp[i,:].fill(numpy.nan)
                        l = False
                        if (debug>0):
                            print "point ({0:12.6e},{1:12.6e}) not inside lcms".format(ir,iz)
                        # end   if (debug>0):
                    # end   if(numpy.max(numpy.abs(Pd)) > d_max):
                # end   if(miscmath.wn_PnPoly([ir,iz], lcms) == 0):
            # end   if(not [ir,iz] in lcms):

            if(l):
                # a guess of (s, theta_B, phi_B):
                # phi_B ~ phi
                # thata_B ~ theta_realspace (defined by magnetic axis and point)
                # s ~ r_eff**2
                # use either values from pre-computed grid 
                # or find some values 'on the fly'
                start_time =  time.time()
                if(self.grid3D.isAvail):
                    stp_guess = self.grid3D.stGuessRPZ(ir, phi, iz, ma=ma)
                elif previous_answer==None:
                    stp_guess = self.stGuessRPZ(ir, phi, iz, ma=ma)
                    print time.time() - start_time
                #else:
                #    stp_guess = previous_answer
                #    print 'using',  previous_answer
                # end   if(self.grid3D.isAvail):

                #print "stp_guess ", stp_guess
                if(numpy.isnan(stp_guess[0])):
                    stp_guess[0] = 0.5
                    print "Attention: Couldn't find proper start value for s. Using s=0.5. CHECK RESULTS!!!"
                    print "change: stp_guess ", stp_guess
                # end   if(numpy.is_nan(stp[0])):
                stp_guess[1] = numpy.mod(stp_guess[1], PI2)
                stp_guess[2] = numpy.mod(stp_guess[2], PI2)
                start_time = time.time()
                res = minpack.leastsq(self.residualRPZ, stp_guess, 
                                      args=([ir,phi,iz]), full_output=1)
                print 'leastsq time : %.2f'%(time.time() - start_time), i
                start_time = time.time()
                #res2 = optimize.minimize(self.residualRPZ2, stp_guess, args=([ir,phi,iz],),method = 'SLSQP')

                stp[i,:] = numpy.round(res[0], 8)
                # in case angles are not not in [0, 2*PI]
                stp[i,1] = numpy.mod(stp[i,1], PI2)
                stp[i,2] = numpy.mod(stp[i,2], PI2)
                #previous_answer = stp[i,:]
                #stp[i,0] = s
                #stp[i,1] = theta_b
                #stp[i,2] = phi_b

                # Final check for accuracy.
                # If accuracy is not reached, return "nan".
                # Check also range for s. 
                # Due to spline extrapolation might be s>1.
                RZt = self.fct_RPZ(stp[i,0], stp[i,1], stp[i,2])
                XYZin = numpy.array([ir*numpy.cos(phi),
                                     ir*numpy.sin(phi),
                                     iz])
                XYZout = numpy.array([RZt[0]*numpy.cos(RZt[1]),
                                      RZt[0]*numpy.sin(RZt[1]),
                                      RZt[2]])
                dist = numpy.sqrt(((XYZin-XYZout)**2).sum())
                if((dist > acc) or (stp[i,0] > 1.) or 
                   numpy.isnan(stp[i,0]) or numpy.isnan(stp[i,1])):
                    if (debug>0):
                        print "dist {0:f} > acc {1:f} {2:s}".format(dist, acc, str(dist > acc)) 
                        print "stp[i,0] > 1., numpy.isnan(stp[i,0]), numpy.isnan(stp[i,1]) ", stp[i,0] > 1, numpy.isnan(stp[i,0]), numpy.isnan(stp[i,1])
                        print "don't keep point no {0:3d} ({1:12.6e},{2:12.6e}): dist={3:12.6e}, s={4:12.6e}".format( i, RZ[i,0], RZ[i,1], dist, stp[i,0])
                    # end   if (debug>0):
                    stp[i,:].fill(numpy.nan)
                # end   if((dist > acc) or (stp[i,0] > 1) or...
            # end   if(l):
        # end   for i in range(no_points):
        if(debug == 0):
            return(stp)
        else:
            #return(stp, grid_r, grid_z, cart_grid_s, cart_grid_theta1, cart_grid_theta2, r_on_bean, z_on_bean)
            return(stp, numpy.nan, numpy.nan, numpy.nan, numpy.nan, numpy.nan, numpy.nan, numpy.nan)



    def stGuessRPZ(self, R, phi, Z, ma=None):
        """
        Make a guess for Boozer coordinates (s, theta_b, phi_b)
        as a function of cylindrical coordinates (R,phi,Z).

        INPUT:
          R, phi, Z ... cylindrical coordinates
          ma .......... cylindrical R,Z of magnetic axis in phi-plane

        RETURN:
          stp ... guess for Boozer coordinates 
                  numpy.array([s, theta_b, phi_b])
        """

        # let's assume cylindrical phi is close enough to phi_b
        phi_b = phi

        if(ma == None):
            phi_b1 = self.invertP(0, 0, phi_b, pureInd=True)
            ma = numpy.empty(2)
            (ma[0],ma[1]) = self.fct_RZ(0, 0, phi_b1)
        else:
            ma = numpy.array(ma)
            if(ma.shape != (2,)):
                raise Exception, "".join(["Coordinates of magnetic axis ma ",
                                          "must be array type with length ",
                                          "of 2, e.g. ma = (R,Z)!"])
            # end   if(shape != (2,)):
        # end   if(ma == None):

        theta_b = numpy.arctan2(Z-ma[1], R-ma[0])
        #print 'phi_b, theta_b ', phi_b, theta_b
        crs = self.getCrossSectData(phi_b, None, s_ind=-1, 
                                    no_theta=30, coordsys='cyl',
                                    theta_s=theta_b-PI/2., 
                                    theta_e=theta_b+PI/2.,
                                    phi_is_cyl=True)[0]
        #print 'crs=', crs

        PP = numpy.array([R, Z])
        CRS = crs[[0,2],:].T
        RZ = miscmath.lineToFluxSurf(ma, PP, CRS)

        a2_approx = ((ma-RZ)**2).sum()
        r2_approx = ((ma-PP)**2).sum()
        s = min(r2_approx/a2_approx, 1.0)
        #print "r2_approx, a2_approx, s ", r2_approx, a2_approx, s 

        return(numpy.array([s, theta_b, phi_b]))


    ##### some stuff for inverting coordinates end #####

    ##### line trace start #####
    """

import BOOZER
import miscmath

bname='boozmn_VMEC_fb_kh0.500.nc'

boo=BOOZER.BOOZER(bname, compute_spline_type=BOOZER.__all_splines__, load_spline=True, save_spline=False, use_spline_type=BOOZER.SPLINE.CONV_SPLINE, load_grid=True, save_grid=False, compute_grid=False, gnr=7, gnp=12, gnz=8)

x1=boo.fct_RPZ(0,0,0)
x2=boo.fct_RPZ(1,0,0)
x1
Out[197]: (1.2476661146140893, 0.0, 0.0)
x2
Out[202]: (1.3403159818815278, 0.0, 0.0)
p=boo.lineTrace(x1,x2,3)
p
Out[204]: 
array([[ 1.        ,  0.73919827,  6.28318531],
       [ 1.        ,  0.73919827,  6.28318531],
       [ 1.        ,  6.28318531,  6.28318531]])


    p=boo.lineTrace([0,1.2,0],[0,1.3,0],np=3)

    In [192]: p
    Out[192]: 
    array([[ 1.23917666,  5.52232486,  1.71417507],
           [ 1.40165918,  5.61207332,  1.73814862],
           [ 1.4247925 ,  5.64215328,  1.7286742 ]])

    """
    def lineTrace(self, x0, x1, np=10, debug=0):
        """
        Trace a line, which is defined in real space Cartesian (x,y,z) 
        coordinates, in Boozer (s_b, theta_b, phi_b) coordinates.

        INPUT:
          x0, x1 ... Cartesian (x,y,z) coordinates of the two end-points 
                     of the line
          np ....... number of points on the line in Boozer coordinates 
        
        RETURN:
          parr ..... np x 3 array for coordinates of points in 
                     Boozer (s_b, theta_b, phi_b) coordinates
        """
        if(debug > 0):
            print "x0=", x0
            print "x1=", x1
            print "np=", np
        # end   if(debug > 0):

        cartparr = miscmath.pointsOfLine(x0, x1, np)
        cylparr = miscmath.cart2Cyl(cartparr)
        parr = numpy.zeros([np, 3])
        
        for i,c in enumerate(cylparr):
            parr[i] = numpy.array(self.real2Mag(c[1], c[[0,2]], debug=debug))
        # end   for i,c in enumerate(cylparr):

        return(parr)


    ##### line trace end #####

    ##### plotting start #####

    def plotFluxTube(self, s, s_ind=None, no_theta=30, no_phi=180, 
                     adjust_axes=False, figno=None, USE_MAYAVI=True,
                     withB=True, **plkwargs):
        """
        ANSCHAUEN!!!
        http://matplotlib.sourceforge.net/examples/mplot3d/surface3d_demo3.html
        http://matplotlib.sourceforge.net/examples/mplot3d/wire3d_demo.html

        3d plot (geometry) of a flux tube/surface specified by s or s_ind.

        Usage: e.g.:
        boozmn.plotFluxTube(s_ind=-1)

        ATTENTION: Input for s can't be handled until now!
                   Reason: Interpolation (e.g. splines) needed in order
                   to compute Fourier coefficients, e.g. Rmnc(s)...
                   copy/paste from other routines...

        INPUT:
          s .......... flux surface label; array like
          s_ind ...... chosen flux surface index 
          no_theta ... no points on phi=const plane
          no_phi ..... no points in phi direction
          adjust_axes  True/False adjust axes by plotCrossSect()
                       Useful, if equal scaling for the axes is required.
          figno ...... number of figure
          USE_MAYAVI . use mayavi if available
          withB ...... use mod B for color information
          **plkwargs . arguments directly parsed to plot command

        RETURN:
          err ......... 0 for normal operation

        """

        if([s,s_ind].count(None) == 2):
            print "chose either s or s_ind!"
            return(1)
        # end   if([s,s_ind].count(None) == 2):

        if(not(ISOK_MAYAVI & USE_MAYAVI)):
            meshgrid = False
        else:
            meshgrid = True
        # end   if(not(ISOK_MAYAVI & USE_MAYAVI)):

        points = self.getFluxsurfData(s, s_ind=s_ind, 
                                      no_theta=no_theta, no_phi=no_phi,
                                      retB=withB,
                                      coordsys="cart", meshgrid=meshgrid)
        fig = self.doPlot3D(points, phi_b=None, s_b=s, 
                            adjust_axes=adjust_axes, 
                            figno=figno, USE_MAYAVI=USE_MAYAVI, 
                            **plkwargs)

        return(fig)


    def doPlotFluxTube(self, points, s_b=None, adjust_axes=False, 
                       figno=None, USE_MAYAVI=True, **plkwargs):
        """
        Do the 3D plot of a set of data.
        
        INPUT:
          points ..... array of coordinates
                       points.shape:   [nsurf,3,no_theta*no_phi]
          s_b ........ flux surface labels for labelling; array like
          adjust_axes  True/False adjust axes by plotCrossSect()
                       Useful, if equal scaling for the axes is required.
          figno ...... number of figure
          USE_MAYAVI . use mayavi if available
          **plkwargs . arguments directly parsed to plot command
        
        RETURN:
          fig
        """
        cols = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'w']
        ncols = len(cols)

        points = numpy.array(points)

        # it's easier to ensure 3dim array than changing things below
        if(len(points.shape) != 3):
            points = points.reshape((1,)+points.shape)

        nsurf = points.shape[0]

        if(not(ISOK_MAYAVI & USE_MAYAVI)):
            fig = pylab.figure()
            try:
                # try new way. for matplotlib> v1.0.0 
                ax = fig.add_subplot(111, projection='3d')
            except:
                # ok, we need the old way
                ax = Axes3D(fig)

            s_b_str = ""
            if(s_b != None):
                s_b = numpy.array(s_b)
                mv = numpy.abs(s_b).max()
                # stringlength slen:  e.g. a=0.45687
                # we like 3 digs behind komma
                # l = int(numpy.log10(mv)) -> l=0  ;   digits before komma: l+1
                # slen = digits before komma + komma + digs behind komma
                try:
                    slen = int(numpy.log10(mv)) + 1 + 1 + 3
                except:
                    slen = 3

                acc = 1
                s_b_str = r"s={0:s}  ".format(convenience.formatNumberArray(s_b, slen, acc)).replace("'", "")

            title_str = "".join([self.nc_filename, '\n',s_b_str])
            ax.legend()
            ax.set_title(title_str)
            ax.set_aspect('equal')
            ax.set_xlabel('x')
            ax.set_ylabel('y')
            ax.set_zlabel('z')
            ax.grid(True)

            for i in range(nsurf):
                nc = i%ncols
                surf = ax.plot3D(points[i,0,:], points[i,1,:], points[i,2,:], 
                                 color=cols[nc], **plkwargs)
                # for the following a meshgrid is needed
                #surf = ax.plot_wireframe(X, Y, Z, rstride=1, cstride=1)
                #surf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, 
                #                       facecolors=colors, linewidth=0, 
                #                       antialiased=False)

            fig.show()
        else: # if(not(ISOK_MAYAVI & USE_MAYAVI)):
            fig = None
            alpha = 1.0
            fig = mlab.figure(fgcolor=(0, 0, 0), bgcolor=(1, 1, 1))
            plotOK = True
            if(points.shape[1] == 3):
                for i in range(nsurf):
                    fluxsurf = mlab.mesh(points[i,0,:,:], 
                                         points[i,1,:,:], 
                                         points[i,2,:,:], 
                                         opacity=alpha) #colormap='jet'
                # end   for i in range(nsurf):
            elif(points.shape[1] == 4):
                for i in range(nsurf):
                    fluxsurf = mlab.mesh(points[i,0,:,:], 
                                         points[i,1,:,:], 
                                         points[i,2,:,:], 
                                         scalars=points[i,3,:,:], 
                                         opacity=alpha, colormap='jet')
                # end   for i in range(nsurf):
                dB = points[:,3,:,:].max() - points[:,3,:,:].min()
                if(dB < 0.5):
                    fmt_str = '%.2f'
                else:
                    fmt_str = '%.1f'
                # end   if(dB < 0.5):
                clbh = mlab.colorbar(title='B [T]', 
                                     orientation='vertical', 
                                     label_fmt=fmt_str)
            else:
                tstr = "".join(["doPlot3D(): Wrong number of 'columns!\n",
                                "  points.shape must be (nsurf, 3/4, ...)\n",
                                "  second dimension is ",
                                "{0:d} ".format(points.shape[1]),
                                "instead of either 3 or 4!"])
                print tstr
                plotOK = False
            # end   if(points.shape[1] == 3):
            if(plotOK):
                olh = mlab.outline(figure=fig)
                axh = mlab.axes(olh,  # xlabel=r'$\alpha$'
                                xlabel='X', ylabel='Y', zlabel='Z')
                if(adjust_axes):
                    (zmin, zmax) = (xmin, xmax)
                    mlab.axes(axh,
                              extent=[xmin, xmax, ymin, ymax, zmin, zmax])
                # end   if(adjust_axes):
                #mlab.axes(fluxsurf)
                viewh = mlab.view(45.0, 60.0, 7, figure=fig)
                mlab.show()
            # end   if(plotOK):
        # end   if(ISOK_MAYAVI & USE_MAYAVI):

        return(fig)


    def getFluxsurfData(self, s_b, s_ind=None, no_theta=30, no_phi=180,
                        retB=False, coordsys=None, meshgrid=False):
        """
        Compute points on specified fluxtubes/fluxsurfaces.

        ATTENTION: According Eq.(6) in 
        R.Sanchez et al: "Ballooning stability optimization of 
        low-aspect-ratio stellarators", Plasma Phys. Control. Fusion 
        42 (2000) 641-653
        the kernel of the Fourier series is: (m*theta_B - n*M*phi_B)!!!

        ATTENTION:
          At least one flux surface label has to be provided for s!!!
          If s_b >= 0 and s_ind are present, both are used.
            e.g.: wout.getCrossSectData(0, [0.1,0.9], [0,1])
            returns cross section data for s_b=0.1, s_b=0.9, the magnetic axis 
            and the last closed surface at phi=0.
          In case s_b == None, s_ind rather than s is used.
            e.g.: wout.getCrossSectData(0, -1, [0,1])
            returns cross section data for the magnetic axis and 
            the last closed surface at phi=0.

        INPUT:
          s_b ...... flux surface labels (array like)   nsurf=len(s_b)
          s_ind ...... indices of flux surfaces to plot (array like)
          no_theta . no points for Boozer angle like variable theta
          no_phi ... no points for Boozer angle like variable phi
          retB ..... return mod B  (True/False)
          coordsys ... return points in specified coordinate system
                       "cart" (Cartesian, default), "cyl" (cylindrical)
          meshgrid ... output is meshgrid for each fluxsurface
                       points.shape:   [nsurf,x,no_phi,no_theta]

        RETURN:
          points ... array of coordinates
                     points.shape:
                     when meshgrid=True  no_theta*no_phi -> no_theta,no_phi
                     either [nsurf,3,no_theta*no_phi] for retB=False
                     or [nsurf,4,no_theta*no_phi] for retB=True
        """

        if([s_b,s_ind].count(None) == 2):
            raise InputDataError("no values for s_b and s_ind")

        if(coordsys == None):
            coordsys = "cart"

        coordsys = coordsys.lower()

        # s_b should be an array (or array like)
        if(s_b != None):
            try:
                ll = len(s_b)
                s_b = numpy.array(s_b)
            except:
                s_b = numpy.array([s_b])
            # end    try:
        # end   if(s_b != None):

        pureInd = False
        if(s_ind != None):
            s_ind = numpy.array(s_ind)
            if(s_b == None):
                s_b = s_ind  #self.es_b[s_ind]
                pureInd = True
            else:
                s_b = numpy.append(s_b, self.es_b[s_ind])
            # end   if(s_b == None):
        # end   if(s_ind != None):

        # in case s_b is a scalar, make a real array
        if(len(s_b.shape) == 0):
            sb = s_b
            if(pureInd):  
                s_b = numpy.empty([1], dtype=numpy.int)
            else:
                s_b = numpy.empty([1])
            # end   if(pureInd): 
            s_b[0] = sb
        # end   if(len(s_b.shape) == 0):

        points = []

        a = self.phi_b_fact
        t = numpy.linspace(0, PI2, no_theta, endpoint=True)
        p = numpy.linspace(0, PI2, no_phi,   endpoint=True)

        (theta,phi_b) = numpy.meshgrid(t, p)

        for s in s_b:
            if(pureInd):
                rmnc = self.rmnc_b[s]
                zmns = self.zmns_b[s]
                pmns = self.pmns_b[s]
                if(retB):
                    bmnc = self.bmnc_b[s]
                # end   if(retB):
            else:
                rmnc = self.rSpline.eval(s, kindspec=self.splkind)
                zmns = self.zSpline.eval(s, kindspec=self.splkind)
                pmns = self.pSpline.eval(s, kindspec=self.splkind)
                if(retB):
                    bmnc = self.bSpline.eval(s, kindspec=self.splkind)
                # end   if(retB):
            # end   if(pureInd):

            r_c = numpy.zeros(no_theta*no_phi)
            p_c = numpy.zeros(no_theta*no_phi)
            z_c = numpy.zeros(no_theta*no_phi)
            if(retB):
                B = numpy.zeros(no_theta*no_phi)
            # end   if(retB):

            k = 0
            for theta in t:
                for phi_b in p:
                    argv = self.ixm_b*theta + self.kernelSign*self.ixn_b*phi_b
                    cosv = numpy.cos(argv)
                    sinv = numpy.sin(argv)
                    p_c[k] = phi_b + a*numpy.sum(pmns*sinv)
                    r_c[k] = numpy.sum(rmnc*cosv)
                    z_c[k] = numpy.sum(zmns*sinv)
                    if(retB):
                        B[k] = numpy.sum(bmnc*cosv)
                    # end   if(retB):
                    k += 1
                # end   for phi_b in p:
            # end   for theta in t:


            # make meshgrids   reshape([no_theta,no_phi]).transpose()
            if(meshgrid):
                r_c = numpy.reshape(r_c,[no_theta,no_phi]).transpose()
                p_c = numpy.reshape(p_c,[no_theta,no_phi]).transpose()
                z_c = numpy.reshape(z_c,[no_theta,no_phi]).transpose()
                if(retB):
                    B = numpy.reshape(B,[no_theta,no_phi]).transpose()
                # end   if(retB):
            # end   if(meshgrid):

            if(coordsys == "cart"):
                X = r_c * numpy.cos(p_c)
                Y = r_c * numpy.sin(p_c)
                Z = z_c
                if(retB):
                    points.append([X, Y, Z, B])
                else:
                    points.append([X, Y, Z])
            else:
                if(retB):
                    points.append([r_c, p_c, z_c, B])
                else:
                    points.append([r_c, p_c, z_c])
                # end   if(retB):
            # end   if(coordsys == "cart"):
        # end   for s in s_b:

        return(numpy.array(points))



    def plotCrossSect(self, phi_b, s, s_ind=None, no_theta=100, 
                      theta_s=0, theta_e=PI2, phi_is_cyl=False, 
                      adjust_axes=False, method=0, **plkwargs):
        """
        Plot no_theta points on a cross section for each flux surface 
        specified by s or s_ind.

        ATTENTION:
          At least one flux surface label has to be provided for s!!!
          If s_b >= 0 and s_ind are present, both are used.
            e.g.: wout.getCrossSectData(0, [0.1,0.9], [0,1])
            returns cross section data for s_b=0.1, s_b=0.9, the magnetic axis 
            and the last closed surface at phi=0.
          In case s_b == None, s_ind rather than s is used.
            e.g.: wout.getCrossSectData(0, -1, [0,1])
            returns cross section data for the magnetic axis and 
            the last closed surface at phi=0.


       Usage: e.g.:
        boozmn.plotCrossSect(numpy.deg2rad(30), 0.7, s_ind=[0,-1])


        INPUT:
          phi_b ...... Boozer toroidal angle in rad
          s .......... flux surface label; array like
          s_ind ...... chosen flux surface index 
          no_theta ... no points on phi=const plane
          theta_s .... start value for theta in rad
          theta_e .... end value for theta in rad
          phi_is_cyl . indicates whether phi_b is Boozer (False) or
                       cylindrical (True) angle
          adjust_axes  True/False adjust axes by plotCrossSect()
                       Useful, if equal scaling for the axes is required.
          USE_MAYAVI . use mayavi if available (not implemented; set to False)
          **plkwargs . arguments parsed dirctly to plot command

        RETURN:
          err ......... 0 for normal operation

        """

        if([s,s_ind].count(None) == 2):
            raise InputDataError("no values for s and s_ind")

        """
        if(s != None):
            try:
                ll = len(s)
                s_b = numpy.array(s)
            except:
                s_b = numpy.array([s])

        if(s_ind != None):
            s_ind = numpy.array(s_ind)
            if(s == None):
                s_b = self.es_b[s_ind]
            else:
                s_b = numpy.append(s_b, self.es_b[s_ind])

        s = s_b
        """
        USE_MAYAVI = False

        if(not(ISOK_MAYAVI & USE_MAYAVI)):
            meshgrid = False
        else:
            meshgrid = True

        points = self.getCrossSectData(phi_b, s, s_ind=s_ind, 
                                       no_theta=no_theta, 
                                       theta_s=theta_s, 
                                       theta_e=theta_e,
                                       coordsys="cart",
                                       phi_is_cyl=phi_is_cyl,
                                       meshgrid=meshgrid, method=method)
        """
        if(s_ind != None):
            s = self.es_b[s_ind]
            points = self.getCrossSectDataInd(phi_b, s_ind, 
                                              no_theta=no_theta, 
                                              theta_s=theta_s, 
                                              theta_e=theta_e)
        """

        fig = self.doPlot3D(points, phi_b=phi_b, s_b=s, 
                            adjust_axes=adjust_axes, 
                            USE_MAYAVI=USE_MAYAVI,
                            **plkwargs)

        return(fig)


    def doPlot3D(self, points, phi_b=None, s_b=None, 
                 adjust_axes=False, figno=None, USE_MAYAVI=True,
                 **plkwargs):
        """
        Do the 3d plot of a dataset.
        
        INPUT:
          points ..... array of coordinates
                       points.shape:   [nsurf,3,no_theta*no_phi]
          phi_b ...... Boozer angle like variable, defines cross section
          s_b ........ flux surface labels; array like
          adjust_axes  True/False adjust axes by plotCrossSect()
                       Useful, if equal scaling for the axes is required.
          figno ...... number of figure
          USE_MAYAVI . use mayavi if available
          **plkwargs . arguments directly parsed to plot command
        
        RETURN:
          fig
        """
        try:
            from mayavi import mlab
            ISOK_MAYAVI = True
        except:
            ISOK_MAYAVI = False
        cols = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'w']
        ncols = len(cols)

        nsurf = points.shape[0]
        if(s_b == None):
            nlegs = 0
        else:
            try:
                nlegs = len(s_b)
            except:
                nlegs = 1  # when we are her, s_b should be a scalar

        if((nlegs != nsurf) & (nlegs != 0)):
            print "Numers of fluxsurfaces and fluxsurface labes do not match."
            print "Don't show fluxfurface labels."
            s_b = None
            nlegs = 0

        # adjust axes limits in order to plot 'equal'
        if(adjust_axes):
            dd = 0.05
            xmin = points[:,0,:].min()
            xmax = points[:,0,:].max()
            ymin = points[:,1,:].min()
            ymax = points[:,1,:].max()
            zmin = points[:,2,:].min()
            zmax = points[:,2,:].max()
            dx = (xmax-xmin)*dd
            dy = (ymax-ymin)*dd
            dz = (zmax-zmin)*dd
            xmin -= dx
            xmax += dx
            ymin -= dy
            ymax += dy
            zmin -= dz
            zmax += dz

            dx = xmax - xmin
            dy = ymax - ymin
            dz = zmax - zmin
            if(dx <= dz):
                xmin = (xmin+xmax)/2 - dz/2.
                xmax = (xmin+xmax)/2 + dz/2.
            else:
                zmin = (zmin+zmax)/2 - dx/2.
                zmax = (zmin+zmax)/2 + dr/2.

                zmax = (zmin+zmax)/2 + dx/2.
            # end   if(dx <= dz):
        # end   if(adjust_axes):

        if(not(ISOK_MAYAVI & USE_MAYAVI)):
            fig = pylab.figure()
            try:
                # try new way. for matplotlib> v1.0.0 
                ax = fig.add_subplot(111, projection='3d')
            except:
                # ok, we need the old way
                ax = Axes3D(fig)

            pylab.rcParams['legend.fontsize']='small'

            s_b_str = ""
            if(s_b != None):
                try:
                    ll = len(s_b)
                    s_b = numpy.array(s_b)
                except:
                    s_b = numpy.array([s_b])

                mv = numpy.abs(s_b).max()
                # stringlength slen:  e.g. a=0.45687
                # we like 3 digs behind komma
                # l = int(numpy.log10(mv)) -> l=0  ;   digits before komma: l+1
                # slen = digits before komma + komma + digs behind komma
                if(mv > 0.0):
                    slen = int(numpy.log10(mv)) + 1 + 1 + 3
                else:
                    slen = 3

                acc = 1

            if(phi_b != None):
                title_str = "".join([self.nc_filename.strip(), '\n',
                                     r"$\varphi={0:.2f}^\circ$".format(numpy.rad2deg(phi_b))])
            else:
                 title_str = self.nc_filename.strip()

            ax.set_title(title_str)
            ax.set_aspect('equal')
            ax.set_xlabel('X')
            ax.set_ylabel('Y')
            ax.set_zlabel('Z')
            ax.grid(True)

            surf = []
            legl = []
            legt = []

            if(plkwargs.has_key('marker')):
                predefmarker = plkwargs['marker']
            else:
                predefmarker = ''

            llen = -1
            for i in range(nsurf):
                if(s_b != None):
                    # set marker, if not set, for axis to '+'
                    try:
                        sb = s_b[i]
                    except:
                        sb = s_b
                    if(sb == 0.0):
                        if(not plkwargs.has_key('marker')):
                            plkwargs.update({'marker':'+'})
                    else:
                        if(plkwargs.has_key('marker')):
                            plkwargs.update({'marker':predefmarker})

                nc = i%ncols
                print "**plkwargs ", plkwargs
                ll, = ax.plot3D(points[i,0,:], points[i,1,:], points[i,2,:],
                                **plkwargs)
                if(nlegs != 0):
                    legl.append(ll)
                    legt.append("s={0:s}".format(convenience.formatNumber(s_b[i], slen, acc)))
                    llen = max(llen, len(legt[-1]))

                ax.hold(True)


            # Put a legend below current axis
            ncols = 40 / llen
            if(nlegs != 0):
                leg = ax.legend(legl, legt, loc='upper center',
                                bbox_to_anchor=(0.5, 0.01), numpoints=1, ncol=ncols)


            ax.set_aspect('equal')
            ax.grid(True)
            if(adjust_axes):
                ax.set_xlim(xmin, xmax)
                ax.set_ylim(zmin, zmax)
            fig.show()
        else: # if(not(ISOK_MAYAVI & USE_MAYAVI)):
            fig = None
            alpha = 1.0
            fig = mlab.figure(fgcolor=(0, 0, 0), bgcolor=(1, 1, 1))
            plotOK = True
            if(points.shape[1] == 3):
                for i in range(nsurf):
                    fluxsurf = mlab.mesh(points[i,0,:,:], 
                                         points[i,1,:,:], 
                                         points[i,2,:,:], 
                                         opacity=alpha) #colormap='jet'
                # end   for i in range(nsurf):
            elif(points.shape[1] == 4):
                for i in range(nsurf):
                    fluxsurf = mlab.mesh(points[i,0,:,:], 
                                         points[i,1,:,:], 
                                         points[i,2,:,:], 
                                         scalars=points[i,3,:,:], 
                                         opacity=alpha, colormap='jet')
                # end   for i in range(nsurf):
                dB = points[:,3,:,:].max() - points[:,3,:,:].min()
                if(dB < 0.5):
                    fmt_str = '%.2f'
                else:
                    fmt_str = '%.1f'
                # end   if(dB < 0.5):
                clbh = mlab.colorbar(title='B [T]', 
                                     orientation='vertical', 
                                     label_fmt=fmt_str)
            else:
                tstr = "".join(["doPlot3D(): Wrong number of 'columns!\n",
                                "  points.shape must be (nsurf, 3/4, ...)\n",
                                "  second dimension is ",
                                "{0:d} ".format(points.shape[1]),
                                "instead of either 3 or 4!"])
                print tstr
                plotOK = False
            # end   if(points.shape[1] == 3):
            if(plotOK):
                olh = mlab.outline(figure=fig)
                axh = mlab.axes(olh,  # xlabel=r'$\alpha$'
                                xlabel='X', ylabel='Y', zlabel='Z')
                if(adjust_axes):
                    (zmin, zmax) = (xmin, xmax)
                    mlab.axes(axh,
                              extent=[xmin, xmax, ymin, ymax, zmin, zmax])
                # end   if(adjust_axes):
                #mlab.axes(fluxsurf)
                viewh = mlab.view(45.0, 60.0, 7, figure=fig)
                mlab.show()
            # end   if(plotOK):
        # end   if(ISOK_MAYAVI & USE_MAYAVI):

        return(fig)


    def getCrossSectData(self, phi_b, s_b, s_ind=None, no_theta=30, 
                         theta_s=0, theta_e=PI2, coordsys=None,
                         phi_is_cyl=False, meshgrid=False, method=0, return_booz_also=0):
        """
        Calculate points on cross section specified by toroidal 
        Boozer angle phi_b.

        ATTENTION: According Eq.(6) in 
        R.Sanchez et al: "Ballooning stability optimization of 
        low-aspect-ratio stellarators", Plasma Phys. Control. Fusion 
        42 (2000) 641-653
        the kernel of the Fourier series is: (m*theta_B + n*N*phi_B)!!!

        ATTENTION:
          At least one flux surface label has to be provided for s!!!
          If s_b >= 0 and s_ind are present, both are used.
            e.g.: wout.getCrossSectData(0, [0.1,0.9], [0,1])
            returns cross section data for s_b=0.1, s_b=0.9, the magnetic axis 
            and the last closed surface at phi=0.
          In case s_b == None, s_ind rather than s is used.
            e.g.: wout.getCrossSectData(0, -1, [0,1])
            returns cross section data for the magnetic axis and 
            the last closed surface at phi=0.

        
        INPUT:
          phi_b ...... Boozer toroidal angle in rad
          s_b ........ flux surface label (array like)   nsurf=len(s_b)
          s_ind ...... indices of flux surfaces to plot (array like)
          no_theta ... no points on phi=const plane
          theta_s .... start value for theta in rad
          theta_e .... end value for theta in rad
          coordsys ... return points in specified coordinate system
                       "cart" (Cartesian, default), "cyl" (cylindrical)
          phi_is_cyl . indicates whether phi_b is Boozer (False) or
                       cylindrical (True) angle
          meshgrid ... output is meshgrid for each fluxsurface
                       points.shape:   [nsurf,x,no_phi,no_theta]
          return_booz_also return the boozer coordinates [s, phi, th] also (SH:6May2013)

        RETURN:
          points ... array of coordinates
                     points.shape:   [nsurf,3,no_theta]
                     when meshgrid=True  no_theta*no_phi -> no_theta,no_phi
                     either [nsurf,3,no_theta*no_phi] for retB=False
                     or [nsurf,4,no_theta*no_phi] for retB=True

        """

        if([s_b,s_ind].count(None) == 2):
            raise InputDataError("no values for s_b and s_ind")

        if(coordsys == None):
            coordsys = "cart"

        coordsys = coordsys.lower()

        # s_b should be an array (or array like)
        if(s_b != None):
            try:
                ll = len(s_b)
                s_b = numpy.array(s_b)
            except:
                s_b = numpy.array([s_b])
            # end    try:
            pureInd = False
        else:
            pureInd = True
        # end   if(s_b != None):

        if(s_ind != None):
            s_ind = numpy.array(s_ind)
            if(s_b == None):
                s_b = s_ind  #self.es_b[s_ind]
                pureInd = True
            else:
                s_b = numpy.append(s_b, self.es_b[s_ind])
            # end   if(s_b == None):
        # end   if(s_ind != None):

        # in case s_b is a scalar, make a real array
        if(len(s_b.shape) == 0):
            sb = s_b
            if(pureInd):  
                s_b = numpy.empty([1], dtype=numpy.int)
            else:
                s_b = numpy.empty([1])
            # end   if(pureInd): 
            s_b[0] = sb
        # end   if(len(s_b.shape) == 0):

        points = []
        points_booz = []
        phi_bi = phi_b
        #phi_bi = numpy.mod(phi_b,PI2)

        theta = numpy.linspace(theta_s, theta_e, no_theta, endpoint=True)
        a = self.phi_b_fact

        for s in s_b:
            if(pureInd):
                rmnc = self.rmnc_b[s]
                zmns = self.zmns_b[s]
                pmns = self.pmns_b[s]
            else:
                rmnc = self.rSpline.eval(s, kindspec=self.splkind, deriv=False)
                zmns = self.zSpline.eval(s, kindspec=self.splkind, deriv=False)
                pmns = self.pSpline.eval(s, kindspec=self.splkind, deriv=False)
            # end   if(pureInd):

            r_c = numpy.zeros(no_theta)
            p_c = numpy.zeros(no_theta)
            z_c = numpy.zeros(no_theta)


            s_booz = numpy.zeros(no_theta)
            t_booz = numpy.zeros(no_theta)
            p_booz = numpy.zeros(no_theta)
            for (i,thet) in enumerate(theta):
                # do we have to invert phi?
                if(phi_is_cyl):
                    if(method==0):
                        p_guess = phi_bi
                        res = minpack.fsolve(self.residualP, p_guess, 
                                             args=[p_guess, s, thet, pureInd],
                                             full_output=1)
                        phi_b = res[0][0]
                    else:
                        phi_b = self.invertP(s, thet, phi_bi, pureInd=pureInd)
                    # end   if(method==0):

                else:
                    phi_b = phi_bi
                # end   if(phi_is_cyl):
                if(pureInd):
                    s11 = self.es_b[s]
                else:
                    s11 = s
                # end   if(pureInd):

                argv = self.ixm_b*thet + self.kernelSign*self.ixn_b*phi_b
                cosv = numpy.cos(argv)
                sinv = numpy.sin(argv)
                r_c[i] = numpy.sum(rmnc*cosv)
                p_c[i] = phi_b + a*numpy.sum(pmns*sinv)
                z_c[i] = numpy.sum(zmns*sinv)
                s_booz[i] = s11
                p_booz[i] = phi_b
                t_booz[i] = thet
                
            # end   for (i,thet) in enumerate(theta):

            # make meshgrids   reshape([no_theta,no_phi]).transpose()
            if(meshgrid):
                try:
                    no_phi = len(phi_b)
                except:
                    no_phi = 1
                # end   try:
                r_c = numpy.reshape(r_c,[no_theta,no_phi]).transpose()
                p_c = numpy.reshape(p_c,[no_theta,no_phi]).transpose()
                z_c = numpy.reshape(z_c,[no_theta,no_phi]).transpose()
            # end   if(meshgrid):

            if(coordsys == "cart"):
                X = r_c * numpy.cos(p_c)
                Y = r_c * numpy.sin(p_c)
                Z = z_c
                points.append([X,Y,Z])
            elif(coordsys == "cyl"):
                points.append([r_c, p_c, z_c])
            else:
                raise UnknownCoordSysError("BOOZER getCrossSectData(): unknown coordinate system")
            points_booz.append([s_booz,p_booz,t_booz])
            # end   if(coordsys == "cart"):
        # end   for s in s_b:
        if return_booz_also:
            return numpy.array(points), numpy.array(points_booz)
        else:
            return(numpy.array(points))

    def v(self, theta,phi):
        x=0.0
        for j in range(len(self.ixm_b)):
            x=x+self.phi_b_fact*self.pmns_b[-1,j]*numpy.sin(self.ixm_b[j]*theta + self.ixn_b[j]*phi)   
            return x

    def invertPxxx(self, s, theta, phi_rs, pureInd=False):
#    def phioth(self,theta,cont):
        print "inv P"
        cont=phi_rs
        def vphi(phi):
            return self.v(theta,phi)-cont
        return optimize.fsolve(vphi,0)


    def invertP(self, s, theta, phi_rs, pureInd=False):
        """
        fct_P(self, s, theta_b, phi_b, calc_derivs=False, pureInd=True)
        phi_rs = phi_bi
        
        """
        calc_derivs=False
        def vphi(phi, args):
                return self.fct_P(args[0], args[1], phi, calc_derivs=args[2], pureInd=args[3])-phi_rs

        phi_b = minpack.fsolve(vphi,0,args=[s, theta, calc_derivs, pureInd])
        return(phi_b)


    def getCrossSectDataInd(self, phi_b, s_ind, no_theta=30, 
                         theta_s=0, theta_e=PI2):
        """
        Calculate points on cross section specified by toroidal 
        BOOZER angle phi.

        
        ATTENTION: 
        * Just for data in precomputed fluxsurfaces!

        INPUT:
          phi_b ...... Boozer toroidal angle in rad
          s_ind ...... flux surface index, array like; nsurf=len(s_ind)
          no_theta ... no points on phi=const plane
          theta_s .... start value for theta in rad
          theta_e .... end value for theta in rad

        RETURN:
          points ... array of coordinates
                     points.shape:   [nsurf,3,no_theta*no_phi]

        """

        # s_ind should be an array (or array like)
        try:
            ll = len(s_ind)
            s_ind = numpy.array(s_ind)
        except:
            s_ind = numpy.array([s_ind])

        points = []

        #phi_b = numpy.mod(phi_b,PI2)
        #theta = numpy.linspace(0, PI2, no_theta, endpoint=True)
        theta = numpy.linspace(theta_s, theta_e, no_theta, endpoint=True)
        a = self.phi_b_fact

        for i in s_ind:
            rmnc = self.rmnc_b[i][:]
            zmns = self.zmns_b[i][:]
            pmns = self.pmns_b[i][:]

            r_c = numpy.zeros(no_theta)
            p_c = numpy.zeros(no_theta)
            z_c = numpy.zeros(no_theta)
            for (i,thet) in enumerate(theta):
                argv = self.ixm_b*thet + self.ixn_b*phi_b
                cosv = numpy.cos(argv)
                sinv = numpy.sin(argv)
                r_c[i] = numpy.sum(rmnc*cosv)
                p_c[i] = phi_b + a*numpy.sum(pmns*sinv)
                z_c[i] = numpy.sum(zmns*sinv)

            X = r_c * numpy.cos(p_c)
            Y = r_c * numpy.sin(p_c)
            Z = z_c

            points.append([X,Y,Z])

        return(numpy.array(points))

    ##### plotting end #####


    ##### misc start #####

    def writeNeoInput(self, R=None, a=None):
        """
        Write a ascii textfile based on bmn*.nc for NEO input.
        Scheme of output filenames: Bmns.configname

        Fileformat see: 
        line 217ff   SUBROUTINE boozer_write
        /home/seiwald/DISSERTATION/FORTRAN90/VMEC_PP/boozer_io.f90

        In general the format from IPP Greifswald is preferable!
        This format allows for some commentlines at the file header.

        As the Boozer file bmn*.nc does not contain the major radius and
        the plasma radius these quantities have either be provided as
        input or determined from the corresponding VMEC file wout*.nc.

        Output should be fine for the following switched used in neo:
        inp_swi = 8
        lab_swi = 8

        INPUT:
          R ... major radius
          a ... plasma radius

        RETURN:
          err . 0 ... no error
                1 ... can't determine R, a

        """

        
        # some 'text line constants'
        line1  = "  m0b  n0b  nsurf  nper flux/[Tm^2]   a/[m]     R/[m]\n"
        line2  = "    s          iota     curr_pol/[A]  curr_tor/[A]  pprime   sqrt g(0,0)\n"
        # line2a1 and line2a2 for inp_swi=6 in neo
        line2a1  = "    s          iota     curr_pol  curr_tor  pprime   sqrt g(0,0)\n"
        line2a2 = "                            [A]       [A]   dp/ds,[Pa] (dV/ds)/nper\n"
        line3  = "    m    n        r/[m]        z/[m]     (phib-phi)*nper/twopi    bmn/[T]\n"

        # useful format strings; like in my old f90 routine
        #format_booz1  = "(4i5,3f16.10)"
        format_booz1 = " {0:4d} {1:4d} {2:4d} {3:4d} {4:13.6e} {5:9.5f} {6:9.5f}\n"
        #format_booz2  = "(1p,6e12.4)"
        format_booz2 = " {0:11.4e} {1:11.4e} {2:11.4e} {3:11.4e} {4:11.4e} {5:11.4e}\n"
        #format_booz3  = "(2i5,1p,4e16.8)"
        format_booz3 = " {0:4d} {1:4d} {2:15.8e} {3:15.8e} {4:15.8e} {5:15.8e}\n"


        # generate proper filename
        configname = os.path.basename(self.nc_filename)
        configname = configname.replace('.nc', '')
        configname = configname.replace('boozmn_wout_VMEC_', '')
        configname = configname.replace('boozmn_VMEC_', '')
        configname = configname.replace('boozmn_wout', '')
        configname = configname.replace('boozmn_', '')

        if(not self.import_all):
            self.importAll()

        es = numpy.linspace(0, 1, self.ns_b)
        ds = es[1]-es[0]
        es_spl = es-ds/2.

        # now for half grid quantities:
        # VMEC and BOOZ_XFORM write 0 into first element of half grid quantities
        # spline for iota
        iota_splrep = interpolate.InterpolatedUnivariateSpline(es_spl[1:], self.iota_b[1:])
        iota = iota_splrep(es)
        #iota_tck = interpolate.splrep(es_spl[1:], self.iota_b[1:])
        #iota_spl = interpolate.splev(es, iota_tck)
        # spline for pres
        pres_splrep = interpolate.InterpolatedUnivariateSpline(es_spl[1:], self.pres_b[1:])
        pres = pres_splrep(es)
        # some trick for derivatives because spline cannot calculate 
        # derivatives for es[0] and es[-1]
        # solution: spline the derivative and extrapolate
        es1 = numpy.linspace(0-ds,1+ds,es.size+2)
        pprime = numpy.zeros(self.ns_b)
        for i in range(1,self.ns_b-1):
            pprime[i] = pres_splrep.derivatives(es[i])[1]

        pp_splrep = interpolate.InterpolatedUnivariateSpline(es[1:-2], pprime[1:-2])
        pprime = pp_splrep(es)

        if ([R, a].count(None) > 0):
            wout_fname = self.nc_filename.replace('boozmn', 'wout')
            print "Trying to determine R and a from {0}".format(wout_fname)
            # if(not "VMEC" in sys.modules):  # not safe...
            try:
                vmecmodulename = VMEC.__name__
            except:
                try:
                    import VMEC
                except:
                    print "Can't determine R, a.   Aborting..."
                    return

            wout = VMEC.VMEC(wout_fname)
            (R1, a1) = wout.determineRA()
            if(R == None):
                R = R1
            if(a == None):
                a = a1


        # factor for eliminating nper in n_boo if necessary
        nfac = 1
        if(self.nboz_b > 1):
            nfac = self.ixn_b[1] - self.ixn_b[0]

        bc_fname = self.nc_filename.replace('boozmn', 'Bmns')
        bc_fname = bc_fname.replace('.nc', '.bc')

        fd = open(bc_fname, 'w')
        fd.write("".join(["CC Author B. Seiwald Created: ",
                          "{0:02d}:{1:02d}:{2:4d}\n".format(time.localtime()[2],
                                                          time.localtime()[1],
                                                          time.localtime()[0])]))
        fd.write("".join(["CC based on calculation: %s\n" %(self.nc_filename)]))
        fd.write("CC <beta> = {0}\n".format(self.beta_b.sum()/self.ns_b))
        #fd.write("CC Configurationname = {0}\n".format(self.nc_filename))
        fd.write("CC Configurationname = ; inp_swi=8, lab_swi=8 in neo?\n")
        fd.write(line1)
        fd.write(format_booz1.format(self.mboz_b-1, self.nboz_b, 
                                     self.pack_rad, self.nfp_b, 
                                     self.phi_b[-1], a, R))
        # In bmn*.nc we find pack_rad (=comput_surfs) computed surfaces.
        # jlist[comput_surfs] gives the index of the surfaces
        # computed by VMEC. These indices we need to access the correct 
        # values of profile quantities, e.g. iota_b, as for the
        # profile quantities all the by VMEC computed values are
        # present in the bmn*.nc
        for i in range(self.pack_rad):
            k = self.jlist[i]
            #fd.write(line2)
            # write line2a1 and line2a2 for inp_swi=6 in neo
            fd.write(line2a1)
            fd.write(line2a2)
            """
            # linear interpolation for iota as it is done in wout*.nc?
            if(k+1 < self.pack_rad):
                iota = (self.iota_b[k]+self.iota_b[k+1])/2.
            elif(self.pack_rad == k+1):
                iota = self.iota_b[k]+(self.iota_b[k]-self.iota_b[k+1])*1.5
            else:
                print "Houston, we've had a problem..."
                df.close()
                return(1)
            """
            # iota is a half grid quantity in boozmn*.nc -> using spline
            # currents in Ampere
            #cur_pol(s)=J(s)=bsubv(i,0) * TWOPI / DMU0 / nper_boo
            cur_pol = self.bvco_b[k] * PI2 / self.DMU0 / self.nfp_b
            #cur_tor(s)=I(s)=bsubu(i,0) * TWOPI / DMU0
            cur_tor = self.buco_b[k] * PI2 / self.DMU0
            # pres is a half grid quantity in boozmn*.nc -> using spline
            sqrt_g00 = self.gmn_b[i,0]
            fd.write(format_booz2.format(es[k], iota[k], 
                                         cur_pol, cur_tor,
                                         pprime[k], sqrt_g00))
            fd.write(line3)
            for imn in range(self.mnboz_b):
                fd.write(format_booz3.format(int(self.ixm_b[imn]), 
                                             int(self.ixn_b[imn]/nfac),
                                             self.rmnc_b[i,imn], 
                                             self.zmns_b[i,imn],
                                             self.pmns_b[i,imn],
                                             self.bmnc_b[i,imn]))

        fd.close()

        return(0)

    ##### misc end #####



"""

Koordinateninversion:

Start mit Boozer Koordinaten
s,t,p = (0.112, 0.7, 1.3)
Einsetzen in die R=sum..., phi=sum..., Z=sum... fuehrt zu
R, P, Z = (0.89987795641186041, 0.78773317692731515, 0.20240360968255566)

Invertieren mit guess1
st_guess1 = (1,0,0)
fuehrt zu
s,t,p = (0.02697021,  3.40282899, -0.69850326)

Invertieren mit guess2
st_guess2 = (0.1,0.5,1.2)
fuehrt zu
s,t,p = (0.112, 0.7, 1.3)

Nun setze ich diese beiden Loesungen wieder in die R=... usw ein und rechne mir die beiden R,P,Z aus.
Beide Saetze von s,t,p liefern praktisch identische R,P,Z:
delta R, delta P, delta Z = 3.05798464e-09,   2.27639516e-07,   1.75057407e-09


2. Bsp:
s,t,p = (0.92, 2.7, 1.9)
R,P,Z = (1.0682549677547635, 1.9993488716620709, 0.17213497602029804)

st_guess1 = (1,0,0)
res=minpack.leastsq(residual, st_guess1, args=([R,P,Z]), full_output=1)
s,t,p = (-0.0282844 ,  1.82386265, -0.54427502)

st_guess2 = (0.1,0.5,1.2)
res=minpack.leastsq(residual, st_guess2, args=([R,P,Z]), full_output=1)
s,t,p = (1.01841581, -3.68756327,  1.92239666)

st_guess3 = (0.9,2.5,2.2)
res=minpack.leastsq(residual, st_guess3, args=([R,P,Z]), full_output=1)
s,t,p = (1.01841581,  2.59562204,  1.92239666)

st_guess4 = (0.93, 2.9, 1.9)
res=minpack.leastsq(residual, st_guess4, args=([R,P,Z]), full_output=1)
s,t,p = (0.92,  2.7 ,  1.9)

----

from scipy.optimize import minpack
(s,t,p)=(0.92, 2.7, 1.9)
(R,P,Z)=boo.fct_RPZ(s,t,p)
st_guess1 = (1,0,0)
res=minpack.leastsq(boo.residualRPZ, st_guess1, args=([R,P,Z]), full_output=1)


"""
